---
id: [feature-id]
title: [feature-name]
author: [product-manager]
description: "This document defines the what and why of the {feature-name} feature for architects and engineers. The document is generated by Catalyst AI and reviewed by the feature PM."
dependencies:
  - [list-of-dependent-feature-ids]
---

<!-- markdownlint-disable single-title -->

# Feature: {feature-name}

> [INSTRUCTIONS]
> Think deeply about the requested feature and fill out the sections of this specification autonomously. If market analysis or a competitive analysis exist in the `.xe/specs/{feature-id}` folder, use them to inform the feature requirements to make the feature competitive in the market. Follow instructions in each `> [INSTRUCTIONS]` block and remove the instructions when complete. Focus on WHAT users need and WHY. Avoid HOW to implement (no tech stack, APIs, code structure). This document is written for business stakeholders, not developers.

## Problem

> [INSTRUCTIONS]
> 1-2 sentences explaining WHY this feature is needed.

## Goals

> [INSTRUCTIONS]
> List of what this feature must enable to be successful.

Explicit non-goals:

> [INSTRUCTIONS]
> List of explicit non-goals this feature _won't_ cover (to prevent scope creep or misinterpretation).

## Scenario

> [INSTRUCTIONS]
> List of user stories and outcomes. User stories must be formatted as `As a {persona}, I need to {action-to-perform} so that {goal-or-value-prop}`. Include a nested bullet with the expected outcome to define what must be measurably better with this feature, using an `Outcome: ` prefix for clarity.

## Success Criteria

> [INSTRUCTIONS]
> List of clear, measurable, outcome-driven conditions that must be true for the feature to be considered successfully implemented. Each bullet should describe an observable end-state, not implementation details. Use metrics or explicit conditions where possible.

## Design principles

> [INSTRUCTIONS]
> List of high-level, non-negotiable values that should guide implementation decisions, prompt construction, and architectural choices that are new and specific to this feature. Do not add product-wide design principles here. Each principle should have a short name and a nested detailed description to help convey the point and how to implement the principle. Design principles must follow the following guidelines:
>
> - Begin with a short, imperative phrase that reflects a clear design priority (e.g., “Lead with autonomy”, “Favor reversibility”, “Default to traceability”).
> - Principles should be memorable and directive—suitable for headers or spec tags
> - Use declarative statements, not suggestions or instructions (e.g., “Design for graceful degradation” instead of “Handle errors gracefully”).
> - Reflect a value or tradeoff that guides design decisions (e.g., “Favor clarity over brevity” implies a prioritization).
> - Ensure principles are enduring, not tied to specific tech or implementation (e.g., “Fail loud when assumptions are violated” applies across platforms).
> - Avoid generic or vague phrases like “Be user-friendly” or “Use best practices”. (These lack specificity and don’t guide actual decisions.)
> - Prefer imperative phrasing that starts with a verb or strong tone (e.g., “Design for trust over automation speed” or “Default to explicit behavior”).
> - Express a tradeoff or constraint that guides implementation decisions (e.g., autonomy vs. oversight, speed vs. safety).
> - Include a brief rationale (1–2 sentences) that clarifies scope, boundaries, and intended behavior.
> - Prioritize principles that are actionable, opinionated, and enduring across use cases.
> - Optionally include a short rationale (1–2 sentences) after each principle to clarify intent without diluting the principle itself. Use the quote (`>`) markdown format for the description. Rationale should clarify when the principle applies, what it enables, and what it constrains
>
> All generated assets (e.g., code, documentation) for this feature should reflect these design principles in structure, tone, and behavior.
>
> Design principles are effectively constraints and inspiration to reduce friction and streamline decision-making when debating multiple approaches. If you find you are debating a philosophical approach and not coming to a conclusion easily, it is very likely you are missing a foundational design principle that could streamline those types of decisions.
>
> Design principles are intended to be maintained over time. They are not required but encouraged for multi-person teams and highly recommended for larger teams.

## Requirements

> [INSTRUCTIONS]
> Define all functional and non-functional requirements based on the examples below. Each requirement must be specific, unambiguous, and testable with quantitative validation (not subjective). Requirements are numbered and can be broken down into nested, sub-requirements as needed. Only nest requirements for semantic grouping to aid understanding and maintainability. Do not nest requirements more than 5 layers.
>
> If a requirement is unclear, think deeply about different options, their pros and cons, the risks (e.g., irreversible actions), and select a reversible approach that maximizes end user goals without damaging system stability. **DO NOT** select an approach that cannot be reversed. If the decision is determined to be high risk, document it with a clear `> TODO:` that includes a one-line summary and detailed explanation of the risk, options, pros/cons of each option, and a recommendation with justification. Summarize pending `TODO` items for the end user.
>
> - Enumerate behaviors, constraints, and rules.
> - List any hard or preferred technology requirements, like languages, frameworks, tools, etc. Keep tech requirements at an input/output level and include justification for why the technology is required. Do not define requirements for how the solution should be implemented, unless that is critical to the product inputs/outputs.
> - Document any explicit assumptions you are expecting to be in place (e.g. environment configuration, installed tools, user knowledge).
> - Use numbered lists or bullet points for clarity.
> - Include logic that AI should follow (e.g., ranking algorithms, fallback behavior).
> - If the feature involves prompt engineering, include examples and rationale.
> - If the feature uses AI models, what kind of reasoning, tone, or output format is expected?
> - Describe how you will know the output is what you expect it to be.
>
> Ensure the following commonly under-specified areas are covered:
>
> - User types and permissions
> - Data retention/deletion policies
> - Performance targets and scale
> - Error handling behaviors
> - Integration requirements
> - Security/compliance needs

### Functional Requirements

> [INSTRUCTIONS]
> Examples:
>
> - **FR-1**: System MUST [specific capability, e.g., "allow users to create accounts"]
> - **FR-2**: System MUST [specific capability, e.g., "validate email addresses"]
> - **FR-3**: Users MUST be able to [key interaction, e.g., "reset their password"]
> - **FR-4**: System MUST [data requirement, e.g., "persist user preferences"]
> - **FR-5**: System MUST [behavior, e.g., "log all security events"]

### Non-functional requirements

> [INSTRUCTIONS]
> Organize non-functional requirements as sub-bullets under the following areas. Create a new area, if needed. If an area is not applicable for the feature, include a short, one-sentence justification.
>
> - **NFR-1**: Cost & usage efficiency
> - **NFR-2**: Security
> - **NFR-3**: Reliability
> - **NFR-4**: Performance
> - **NFR-5**: Observability
> - **NFR-6**: Accessibility
> - **NFR-7**: Globalization
> - **NFR-8**: Backward compatibility

## Key Entities

> [INSTRUCTIONS]
> If the feature involves data, describe the entities in this section. Separate entities that are owned by this feature (and must be implemented) and entities referenced from other features. If data is not involved, remove this section.

Entities owned by this feature:

- **[Entity 1]**: [What it represents, key attributes without implementation]

Entities from other features:

- **[Entity 2]** ([entity-feature-id]): [What it represents, source feature in parentheses]

Inputs:

> [INSTRUCTIONS]
> List of expected inputs (e.g., data types, formats, sources). Use structured examples (e.g., JSON, external standards) where applicable. Include assumptions about end user environment pre-configuration or the inputs themselves.

Outputs:

> [INSTRUCTIONS]
> List of expected outputs (e.g., UI changes, API responses, file formats). Use structured examples (e.g., mockups, JSON) where applicable. Include any assumptions pertaining to the output and what may be needed by the end user in order to take full advantage of the output.

## Dependencies

> [INSTRUCTIONS]
> List of dependencies and integrations with other components or services.
>
> - Are there any scenarios, features, or infrastructure that should or must be completed first?
> - Are there any specific setup steps or configuration settings that must be in place for this feature to work or be available?
> - Are there any external standards, libraries, frameworks, or tools that should or must be used to implement this feature?
